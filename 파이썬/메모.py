
################################## Day01 & Day02 #################################

# 파이썬 코딩 연습 ->  검색: 온라인 컴파일러 파이썬 
#   (문법 공부)
# 문제 연습 -> solved.ac

# 노션
# 위키독스 (전자문서, 책) - 점프 투 파이썬

# python.org - documentation - python docs - tutorial
# 파이썬 튜토리얼 (관련 자료)


## memory (Ram)
# stack   변수
# heap    변수
# Data    상수
# text    코드


# 입력 input  	input
# 처리 process
# 출력 output  	print


# 프로그래밍 언어 개념
# 		Hardware / Software

# CPU / Memory / HDD 역할

# OS 개념

# 변수 / 상수 / 자료형
# 		파이썬 메모리 구조

# 서식 출력 방법 - format, % , 서식문자, f-string

# 표준 입력 - input()
# 표준 출력 - print()

# 실습 - 프로그램이 동작할 때 입력 - 처리 - 출력 흐름 이해


###################################### Day03 ######################################

# 논리 연산자 
"""
AND  논리곱이라고도 한다.  (2항     □ and □)
 OR  논리합이라고도 한다.  (2항     □  or □)
Not                      (단항     not □ )

short - circuit 평가 (논리연산에서만 의미가 있음.)
and 연산 : 첫 번째 조건이 거짓이면 뒤의 조건을 보지 않는다. ex) False and ... (확인 안함)
 or 연산 : 첫 번째 조건이 참이면 뒤의 조건을 보지 않는다.   ex) True or ... (확인 안함)
"""


# 제어문
"""
분기문 : 조건에 따른 흐름 분기
반복문 : 조건에 따라 코드 반복
"""


###################################### Day04 ######################################

# 반복문
"""
iterable (순회 가능한 객체)

break : 반복을 종료
continue : 현재 반복동작을 다음으로 건너뛴다.

"""


###################################### Day06 ######################################

# 함수
"""
함수는 기능을 미리 정의해두고 필요할 때 호출하여 사용.
중복 코드 작성 방지를 위함.

"""


###################################### Day07 ######################################

# 함수 형태
"""
1) 함수 형태 - 인자와 반환이 없는 함수
def func1():
    print('기능 동작')

func1()
print()

2) 함수 형태 - 인자는 있고 반환이 없는 함수
def func2(n):
    print(f'{n}으로 기능 동작')
    
func2(1)
print()

3) 함수 형태 - 인자는 없고 반환이 있는 함수
def func3():
    print('기능 동작')
    return 10

result = func3()
print(result)
print()

4) 함수 형태 - 인자와 반환이 있는 함수
def func4(n1, n2):
    return n1 + n2

result = func4(10, 20)
print(result)
print()

5) 함수 형태 - 디폴트 매개변수
def func5(n1 = 10, n2 = 20):
    return n1 + n2

print(func5())
print(func5(100))
print(func5(100, 200))
print()

6) 일반 매개변수와 같이 활용
def func(name = 'noname', age): (X)           # 디폴트 값이 지정된 매개변수 다음에 일반 매개변수 선언 불가
def func(age, name='noname'):
    print(name)
    print(age)

func('Hong', 20)
func(20)
func() 오류(age에 전달될 인자가 없으므로)
"""


# Packing/Unpacking
"""
예시 1)
fruits = ["apple", "banana", "cherry"]

fruit1, fruit2, fruit3 = fruits
print(fruit1)  
print(fruit2)  
print(fruit3)  

예시 2)
numbers = [1, 2, 3, 4, 5]

first, *middle, last = numbers 
print(first)  
print(middle) 
print(last)   


1) 함수 형태 - 가변 인자(튜플)
def sum(*args):
    result = 0
    for num in args:
        result += num
    return result

print(sum(1,2,3))
print(sum(1,2,3,4,5))
values = [1,2,3,4,5]
# print(sum(values)) (x)        # 오류 - values 리스트가 묶여서 하나의 자료형으로 넘어간다.
print(sum(*values))             # Unpacking하여 전달

2) 함수 형태 - 가변인자 일반인자 디폴트 매개변수 모두 적용
def func(*args, n, s = 'de'):
    print(f'n:{n}')
    print(f's:{s}')
    for ar in args:
        print(ar)
    print()

func(1, 2, 3, n = 10)
func('hello', 'hi', n = 20)
a = ['a', 2, 'b', 3]
func(a, 'A', n = 30)
# func(a) # n 에 들어갈 인자가 없음     에러: func() missing 1 required positional argument: 'n'

3) 함수 형태 - 키워드 인자
def print_person_info1(name, age, city):
    print("이름:", name)
    print("나이:", age)
    print("도시:", city)

print_person_info1(age = 20, city = '서울', name = '홍길동')
print()

4) 함수 형태 - 가변 키워드 인자(딕셔너리)
def print_person_info2(**kwargs):
    print(kwargs)
    print("이름:", kwargs['name'])
    print("나이:", kwargs.get('age'))
    print("도시:", kwargs['city'])

print_person_info2(name = '홍길동', age = 20, city = '서울')
values = {'name':'홍길동', 'age':20, 'city':'서울'}
#print_person_info2(k=values)   # 오류 k = values와 같이 전달 필요
print_person_info2(**values)    # Unpacking하여 전달
print()

5) 가변 키워드 인자를 받는 함수에서 packing/unpacking 사용
def func(caller = 'Caller', **kargs):
    keys = kargs.keys()
    i = 0
    for key in keys:
        print(f'[{caller}]: {i}번째 인자 {key}: {kargs[key]}')
        i += 1
    print()

func(caller = '홍', a = 10)
func(a = 1, b = 2, c = 3)
func(a = 'hello', b = 'hi')
func(a = ['1', '2', 3], b = (1, 2, 3), caller = '박')
values = {
    'a':['1', '2', 3], 
    'b':(1, 2, 3)
}
func(**values, caller = '박')
func(caller = '최', **values)
"""


# 1. 가변 인자
"""
1) *가변 매개변수 -> 자료 형태: 튜플
   원형: def value(*args):          ==> packing (여러개의 값을 하나로 받음) 
            print(args)                              

        value("hello", "hi")      =>   ("hello", "hi")
        value(1,2,3,4,5)          =>   (1,2,3,4,5)

 만약 자료형이 리스트일 경우          ==> unpacking(*li) (여러개의 값을 가지고 있는 객체를 풀어줌)
 li = [1,2,3,4,5]
        value(li)       =>   ([1,2,3,4,5],)      
 각각의 자료에 접근하기 위해서는 (*li)를 사용한다.  
        value(*li)      =>   (1,2,3,4,5)          

        
2) **가변 매개변수  -> 자료 형태: 딕셔너리
   원형: def value(**args):         ==> packing (여러개의 값을 하나로 받음)
            print(args)  

        value(a=1, b=2, c=3)        =>  {"a" : 1, "b" : 2, "C" : 3}
        value(a={1:1}, b={2:2})     =>  {"a" : {1:1}, "b" : {2:2}}
 
 만약 자료형이 묶여있을 경우          ==> unpacking(*alp) (여러개의 값을 가지고 있는 객체를 풀어줌)
 alp = {'a': 1, 'b': 2, 'c': 3}
       value(va = alp)      =>  {"va" : {'a': 1, 'b': 2, 'c': 3}}   
                                 key값과 value 값이 원하는 대로 매칭 안됨.
       value(**alp)         =>  {'a': 1, 'b': 2, 'c': 3}
"""


# 2. 함수 인수에 초기값 지정
"""
원형: def func(name = "noname", age = 0):
          print(name)
          print(age)
     func()                =>   (noname, 0)
     func("Lee", 20)       =>   ("Lee", 20)

※주의사항 : 왼쪽의 값에는 초기값이 지정 되어있지 않아도 괜찮으나,
            오른쪽의 값에는 반드시 초기값이 지정 되어있어야 한다.
            ex) def func(name, age = 0):           - O
                def func(name = "noname", age):    - X
"""


# 자료형 (mutable, immutable)
"""
1) mutable (변경 가능한)
 - 리스트, 딕셔너리 타입은 변경 가능 
    ex) def func(a):
            a[0] = "HELLO"

    a = ["hello", "hi"]
    print(a)    => ["hello", "hi"]
    func(a)
    print(a)    => ["HELLO", "hi"]


2) immutable (변경 불가능한)
 - 튜플, 기본 데이터 타입은 변경 불가능
    ex) def func(a):
            a = "HELLO"
            print("func: ", a)

    a = "hello"
    func(a)     => "HELLO"
    print(a)    => "hello"
"""


###################################### Day08 ######################################

# 재귀 함수 (강의자료 exam 14 ~ 15.py)
"""
- 자기 자신을 호출하는 함수
- 분할정복에 주로 사용 -> 자료 구조를 구현할 때 재귀함수를 많이 활용됩
- 원형: def recu():
           print("recursive")
           recu()
"""

# Lambda 함수
"""
- 람다 함수는 파이썬에서 익명 함수를 생성하는 방법
- 간결한 문법으로 이름이 없는 간단한 함수를 생성하는데 사용 => 한 줄짜리 함수 정의할 때 사용
- 원형: lambda 매개변수(입력으로 사용되는 인자들): 기능        
    ex) lambda x,y: x + y     => 더하기 함수 

람다 함수 구현 예시
- 람다 함수는 변수로 대입할 수 있음
- 함수 호출 시 매개변수로 전달 가능(함수형 프로그래밍 개념)
ex) add = lambda x,y: x + y
    result = add(3,5)
    print(result)
"""


###################################### Day09 ######################################

# 자료 구조 & 알고리즘
"""
자료 구조
- 선형: 배열, 리스트, 큐, 스택...
- 비선형: 트리, 그래프

알고리즘
"""

# 파이썬 자료형
"""
- list: 동적임, 순서가 있음
- tuple: 고정된 값(상수, 키 저장 용도), 순서가 있음
- dict: key, value를 매칭해서 저장, key값은 중복될 수 없고 value는 중복 가능, 순서가 없음
- set: 집합, 중복 없음, 순서가 없음
"""


###################################### Day10 ######################################

# 이중 리스트 순서 정렬
"""
li = [["원빈", 20], ["현빈", 24], ["강동원", 17], ["송강호", 29]]
print(li)

1) 나이 오름차순
li2 = sorted(li, key = lambda x:x[1])
print(li2)

2) 나이 내림차순
li3 = sorted(li, key = lambda x: -x[1])
print(li3)
"""


###################################### Day11 ######################################

# 튜플 (tuple)
"""
파이썬의 튜플(Tuple)은 불변(immutable)하고 순차적인 데이터 구조로,
여러 값들을 저장하고 관리
변경할 수 없는 특성 때문에 리스트보다 메모리 효율이 높음
데이터가 변경될 수 없는 경우에 적합한 데이터 구조
튜플은 소괄호 () 를 사용하여 표현
튜플의 요소들은 쉼표, 로 구분
"""

# 세트 (set)
"""
set(집합)는 순서가 없고, 중복을 허용하지 않는 가변(mutable) 데이터 구조
중복을 제거하는 데 사용할 수 있음
set(집합)는 중괄호 {} 를 사용하여 표현
요소들은 쉼표, 로 구분
"""

# 딕셔너리 (dict)
"""
딕셔너리는 키(key)와 값(value) 쌍을 저장하는 가변(mutable) 데이터 구조
딕셔너리는 중괄호 {} 를 사용하여 표현
키와 값은 콜론: 으로 구분하고 쌍들은 쉼표, 로 구분
"""


###################################### Day12 ######################################

# Comprehension (컴프리핸션)
"""
Comprehension은 리스트, 사전, 집합 등에서 활용
- 파이썬에서 매우 자주 사용되는 문법 중 하나
- 반복 가능한 객체(iterable object)의 각 항목에 대해 표현식을 평가하여
  새로운 리스트, 사전, 집합을 간단하고 읽기 쉽게 생성하는 방법
- 특정 유형의 반복문을 단순화하고 최적화하여 코드를 간단하게 만들고 가독성을 높임
- 다양한 컬렉션 타입을 간단하게 생성할 수 있도록 도와줌
- 파이썬을 사용할 때는 컴프리헨션을 적극적으로 활용하는 것이 좋음

1) List Comprehension(리스트 컴프리헨션)
  형식: [표현식 for 항목 in iterable if 조건문]
    표현식: 각 항목에서 계산되어 리스트의 요소가 될 값
    항목: iterable 객체의 각 요소를 차례대로 지정하는 변수
    조건문: 항목이 조건문을 만족할 때만 표현식이 계산되어 리스트의 요소가 됨(생략 가능) 

2) Dictionary Comprehension(딕셔너리 컴프리헨션)
  형식: {키: 값 for 항목 in iterable if 조건문}
    항목: iterable 객체의 각 요소를 차례대로 지정하는 변수
    조건문: 항목이 조건문을 만족할 때만 표현식이 계산되어 딕셔너리의 요소가 됨(생략 가능) 
    키: 딕셔너리의 키(key)가 되는 값
    값: 딕셔너리의 값(value)이 되는 값

3) Set Comprehension(집합 컴프리헨션)
  형식: {표현식 for 항목 in iterable if 조건문}
    표현식: 각 항목에서 계산되어 집합의 요소가 될 값
    항목: iterable 객체의 각 요소를 차례대로 지정하는 변수
    조건문: 항목이 조건문을 만족할 때만 표현식이 계산되어 집합의 요소가 됨(생략 가능)
    - 리스트와 동일하지만 중복 값이 제거된 집합을 생성


★ 컴프리헨션은 파이썬의 특징 중 하나! ★
코드를 간결하게 작성할 수 있으며 가독성을 높일 수 있음.
중첩된 컴프리헨션은 오히려 가독성이 떨어지기 때문에 중첩이 필요한 경우 별도의 변수를 사용하는 것을 권장.
컴프리헨션에서는 일반적으로 한 줄에 들어갈 정도로 간단한 표현식을 사용!!

"""


# 튜플 컴프리헨션 제너레이터 표현식
"""
튜플 컴플리헨션 제너레이터 표현식
- 파이썬에서는 튜플 컴프리헨션(tuple comprehension)을 지원하지 않음
- 튜플은 불변(immutable)하기 때문에 컴프리헨션을 통해 값을 생성할 수 없음
- 하지만 제너레이터 표현식(generator expression)을 사용하면 튜플 생성 가능
- 제너레이터 표현식은 컴프리헨션과 비슷하지만, 괄호()를 사용하여 생성하며,
  값을 미리 생성하지 않고 필요할 때마다 생성
 
제너레이터 컴프리헨션
 형식: (표현식 for 항목 in iterable if 조건문)
   표현식: 각 항목에서 계산되어 튜플의 요소가 될 값
   항목: iterable 객체의 각 요소를 차례대로 지정하는 변수
   조건문: 항목이 조건문을 만족할 때만 표현식이 계산되어 튜플의 요소가 됨(생략 가능)
   ==> 결과 값이 제네레이터를 생성

"""


###################################### Day13 ######################################

# 파일 입출력

# 1. JSON 파일을 이용한 파일 입출력 예제
"""
JSON(JavaScript Object Notation)은 자바스크립트에서 사용하는 
객체 표현 방법을 기반으로 한 경량 데이터 교환 형식
JSON은 텍스트 형식으로 되어 있어 사람이 쉽게 읽고 쓸 수 있으면서 
기계가 쉽게 분석하고 생성할 수 있음
파이썬에서는 JSON을 다루기 위한 모듈인 json이 제공됨
"""


# 2. XML 파일을 이용한 파일 입출력 예제
"""
XML(Extensible Markup Language)은 데이터를 저장하고 전송하기 위한 마크업 언어
데이터를 계층적인 구조로 표현하며, 태그와 속성을 이용하여 데이터를 기술
파이썬에서는 XML을 다루기 위한 모듈인 xml.etree.ElementTree가 제공됨
"""

# 3. YAML 파일을 이용한 파일 입출력 예제
"""
YAML(YAML Ain't Markup Language)은 인간이 쉽게 읽고 쓸 수 있는 데이터 직렬화 형식
들여쓰기와 콜론을 이용하여 데이터를 구조화하며, 다양한 데이터 타입을 지원
파이썬에서는 YAML을 다루기 위한 모듈인 PyYAML이 제공됨
모듈 인스톨 필요
    > pip install pyyaml
"""

# 4. Properties 파일을 이용한 파일 입출력 예제
"""
Properties 파일은 키와 값으로 이루어진 텍스트 파일
주로 프로그램 설정 정보나 메시지 등을 저장하기 위해 사용
파이썬에서는 Properties 파일을 다루기 위한 모듈인 configparser가 제공됨
"""

# 5. CSV 파일을 이용한 파일 입출력 예제
"""
CSV 파일은 쉼표(,)로 구분된 텍스트 파일로, 
행과 열로 이루어진 2차원 데이터를 저장하기 위해 사용
파이썬에서는 CSV 파일을 다루기 위한 모듈인 csv가 제공됨
"""

# 6. 엑셀파일
# 모듈 설치 > pip install openpyxl 


###################################### Day14 ######################################

# OOP & class
"""
# OOP (Object Oriented Programing) & Class
# 객체지향 프로그래밍  &  Class

절차지향(구조적) ->  객체지향
ex) C 언어      ->  C++, Java

< Class >
- Class란 객체를 정의해 놓은 설계도 (속성 - 변수, 기능 - 함수)
- 객체생성( = 인스턴스화)
- 원형: class 클래스이름(상속 클래스명):
            <클래스 변수 1>
            <클래스 변수 2>
            ...
            def 클래스함수1(self[인수1, 인수2,,,]):
                <수행할 문장 1>
                <수행할 문장 2> 

                    
- 용어: 캡슐화(은닉), 추상화, 다형성, 상속성
- print(dir(p1)) - p1. 으로 접근 가능한 자료 확인 가능


Class의 변수
- 클래스 변수: 하나의 클래스로 만들어지는 모든 객체가 공유하는 변수
- 객체 변수(self 사용): 객체가 생성될 때 마다 만들어지는 각 객체가 별도로 가지는 변수


Class의 함수와 메서드
- 일반 함수: 클래스에 속하지 않은 함수
- 인스턴스 메서드: 객체 생성 후 객체 참조를 통해 호출 가능한 메서도
                  self 변수를 통해 메서드 호출 객체를 구분하여 객체 변수를 활용
- 클래스 메서드: 클래스 이름을 통해 호출 가능한 메서드
  (@classmethod)   cls를 통해 호출 시 클래스 정보를 전달하여 클래스 변수를 활용
- 스태틱 메서드: 클래스에 속해 있으나 self 가 없는 메서드
  (@staticmethod)  일반 함수를 클래스 멤버인 것 처럼 활용하기 위한 용도


Class의 구성 요소
1) self
- 클래스의 모든 인스턴스 메서드의 첫 번째 인자
- 인스턴스 메서드를 호출한 객체를 참조하는 역할 (인스턴스 생성할 때마다 객체 변수 생성)
- 객체가 인스턴스 메서드를 호출하면 해당 객체의 변수를 참조하기 위해 필요

2) __init__ (생성자)
- 생성자: 하나의 클래스에 __init__ 이름으로 하나만 가질 수 있다
         객체를 생성할 때 객체변수(멤버변수)의 초기값 설정에 활용
- 생성자 오버로딩: __init__ 메서드에 기본인수를 적용하여 비슷하게 구현
                 가변인자와 type(n)등을 활용하여 유연한 생성자 정의 가능

3) __del__ (소멸자)                

"""


###################################### Day15 ######################################

# OOP & class
"""
< 객체지향 중요 개념 >

추상화: 객체로 정의할 대상에 대한 파악
        상속 시 공통 특성을 하나로 묶어 상위 타입을 정의

캡슐화: 관련 있는 속성과 행위를 하나로 묶어 정의(클래스)
        공개할 것과 은닉할 것을 분류(private, public, setter, getter 등)

상속: 기존 클래스를 확장하여 추가 특성을 정의( ~ is a ~ 고려)

다형성: 하나의 타입으로 다양한 타입을 다룰 수 있는 특성
        추상화와 상속의 개념을 활용하는 것

SOLID: 객체지향 설계원칙


< 정보 은닉 > 
파이썬에서 정보 은닉(외부 접근 제한)을 표현하는 방법
- _ (언더스코어) 문자를 이용하여 비슷한 개념을 표현(name mangling)

사용 방법
- _: 외부 접근을 제한한다는 개념 (타 언어에서의 protected 개념과 비슷, 강제성은 없음)
- __: 해당 형식에서만 접근 가능 (타 언어에서의 private 개념과 비슷, 강제성은 없음)


< setter, getter >
- setter: 객체에 속성을 설정하는 역할의 메서드
       = @(x).setter (파이썬 데코레이터)
- getter: 객체의 속성을 반환하는 역할의 메서드
       = @property (파이썬 데코레이터)

"""


###################################### Day16 ######################################

# OOP & class


###################################### Day17 ######################################

# OOP & class
"""
< 상속 >
- 기존의 클래스의 기능에 추가적인 기능을 정의하는 방법
- 상속을 통해 추상화를 이용한 다형성 표현 가능
- super는 부모를 명시
    ex) super().__init__(self, x, y)    -> 부모의 생성자를 호출

    
< 오버라이딩 Overriding(재정의) >
- 부모의 메서드를 자식이 재정의 하는 것
- 다형성 표현 가능


< 다형성 >
- 하나의 이름으로 다양한 형태를 표현할 수 있는 특성
- 일반화(상속을 통한 표현)
- 추상화(공통적인 특성을 선언)
- 다형성(공통적인 특성을 각 클래스의 특성에 맞게 재 정의)
- 일반화 이름을 사용하여 재정의된 함수들을 호출

"""


###################################### Day18 ######################################

# OOP & class
"""
< 다중 상속 >
- 여러 클래스를 상속
- 다양하게 상속을 활용할 수 있음


< isinstance 함수 >
- 객체 타입 확인
- 참조하는 객체가 해당 클래스로 만들어진 것인지 판별(True/False)
- 원형: isinstance(객체참조이름(변수), 클래스)


< 클래스의 관계 표현 >
1) is - a 관계 (상속을 통해 표현)
- 한 클래스가 다른 클래스의 하위 클래스임을 나타냄
- 하위 클래스는 상위 클래스의 모든 속성과 메서드를 상속받음
- 이 관계는 일반적으로 "A는 B의 종류다" 라는 형태로 설명
- ex) "강아지" 클래스가 "동물" 클래스의 하위 클래스라면, 
      "강아지는 동물의 종류이다" 라고 할 수 있다.

2) has - a 관계 (포함하는 관계)
- 한 클래스의 객체가 다른 클래스의 객체를 속성으로 포함하고 있는 경우를 나타냄
- 이 관계는 일반적으로 "A는 B를 가지고 있다"라는 형태로 설명
- ex) "자동차" 클래스가 "엔진" 클래스의 객체를 속성으로 가진다면,
      "자동차는 엔진을 가지고 있다" 라고 할 수 있다.

"""

# Module & Package
"""  Day18/package 폴더, 강사님 자료 참고

< package > 
- __init__.py 파일이 있어야 해당 폴더를 파이썬에서 패키지라고 인식한다.


특정 패키지의 모듈이 다른 패키지의 모듈을 포함하는 형태
- .. : 상위 패키지
- . : 현재 패키지

"""


# Exception (예외)
"""
< Exception(예외) >
- 프로그램 동작 중 문제가 발생되는 것을 예외라고 한다.
- 파이썬 인터프리터가 처리 중 에러가 나면 메시지를 출력하고 종료됨.
- 에러를 무시하고 진행하거나 다른 방법으로 처리되도록 핸들링 가능(예외 처리)
- 예외 처리 기법 작성방법 3가지:
  1) try영역에서 발생되는 모든 예외를 except 에서 처리
      try:
         (예외가 발생할 수 있는 코드가 있는 영역(지역변수 선언 주의))
      except:
         (발생된 예외를 처리하는 코드를 작성하는 영역)

  2) try영역에서 발생되는 예외 중 특정 예외만 선택하여 except에서 처리
      try:
         ret = 4 / 0
      except ZeroDivisionError:                       # 특정 예외만 선택
         print("정수를 0으로 나눌 수 없음")

  3) try영역에서 발생되는 특정 예외에 대해 메시지까지 확인하여 except에서 처리
      try:
         re = 4 / 0
      except ZeroDivisionError as msg:                # as 활용하여 별칭
         print("예외: ", msg)

- try ~ else: else는 try영역에서 예외가 발생되지 않으면 실행되는 영역
              반드시 except: 뒤에 작성
      try:
         re = 4 / 0
      except ZeroDivisionError as msg:
         print("예외: ", msg)
      else:
         print("예외 없음")
      
- try ~ finally: finally는 예외가 발생 여부와 관계없이 무조건 실행되는 영역
                 except: 없이 try 뒤에 작성 가능,  except:가 있다면 뒤에 작성
      ★ finally : 자원을 해제하는 용도로 주로 활용
         ex) 파일 입출력에서 close() 같은 코드를 주로 작성

- pass구문: 아무것도 수행하지 않는다. 예외를 식별할 수 없기 때문에 pass사용은 비추.
- raise 구문으로 직접 예외를 발생시킬 수 있다.
- 예외 클래스 작성하기: 모든 예외 처리 class는 Exception을 참조해야함.
                      내가 class로 예외 클래스 작성 시 Exception 을 반드시 상속받게 만들어야 한다.
"""


###################################### Day19 ######################################


# 데이터베이스
"""
데이터베이스
- 구조적인 방식으로 저장된 자료의 모음


데이터, 정보
- 데이터: 어떠한 자료 혹은 실제 값을 의미
    ex) 전 국민의 나이, 학생들의 성적
- 정보: 데이터를 기반으로 의미가 부여된 것
    ex) 국민의 평균 나이, 학생들 성적의 평균


데이터베이스 특징
- 실시간 접근성: 다수의 사용자의 요구에 대해 실시간으로 처리/응답한다.
- 지속적인 변화: 저장된 데이터는 최신 정보가 정확하게 저장되어 처리되어야 한다.
- 동시 공유: 동일한 데이터를 동시에 서로 다른 목적으로 사용할 수 있어야 한다.
- 내용에 대한 참조: 데이터 레코드들은 주소나 위치에 의해 참조되는 것이 아니락 가지고 있는 값으로 참조

Database Management System (DBMS)
-자료가 저장된 데이터베이스를 관리하는 역할의 시스템 프로그램
-다수의 사용자들이 데이터베이스 내의 데이터를 접근할 수 있도록 해주는 소프트웨어

DBA : 데이터베이스 관리 시스템을 전문적으로 운영하는 직업군(인력)


데이터베이스 자료형 - integer, text 등
제약조건 적용/해제 - constraint
트랜잭션 - begin, rollback, commit

DML(데이터 조작 (CRUD))
- 데이터를 추가(INSERT), 조회(SELECT), 갱신(UPDATE), 삭제(DELETE) 하는데 사용한다.

DDL(데이터 요소와 구조를 정의)
- 테이블 등을 생성(CREATE),제거(DROP)하는데 사용한다.
- 테이블 생성(create table)
- 테이블 삭제(drop table)

"""

###################################### Day20 ######################################


# 파이썬에서 SQLite3 연동
"""
< SQLite3 모듈 >
1) 접속 관련 함수
- connect(): SQLite 데이터베이스에 연결
  ex) conn = sqlite3.connect("example.db")
- cursor(): 데이터베이스와 상호작용. cursor 객체는 SQL쿼리를 실행하고, 결과를 가져옴
  ex) cursor = conn.cursor()
- close(): 데이터베이스 연결을 닫음. cursor 객체와 데이터베이스 연결 객체 모두 호출 필요.
  ex) cursor.close()    conn.close()

  
2) 쿼리 전송 관련 함수
- execute(): 지정된 SQL쿼리를 실행
  ex) cursor.execute("SELECT * FROM users WHERE name=?", ('John',))
- executemany(): 같은 SQL 쿼리를 반복적으로 실행
  ex) data = [('John', 30), ('Jane',25)] 
      cursor.executemany("INSERT INTO users (name, age) VALUES(?,?)", data)


3) 쿼리 결과 관련 함수 (select 쿼리 결과를 이용할 때 사용)
- fetchone(): 결과 세트에서 다음 행(row)을 반환
  ex) row = cursor.fetchone()
- fetchmany(): 결과 세트에서 다음 여러개의 행을 가져옴. size 파라미터를 지정하지 않으면
               기본값으로 cursor.arraysize를 사용(default: 1)
               cursor.arraysize = 100 과 같이 변경 가능.
  ex) rows = cursor.fetchmany(5)
- fetchall(): 결과 세트에서 모든 행을 가져옴
  ex) rows = cursor.fetchall()


4) 트랜젝션 관련 함수 (자동 커밋 모드로 동작. 수동으로 begin을 전송하여 직접 트랜젝션 제어 가능)
- commit(): 데이터베이스에 변경 사항을 영구적으로 적용하기 위해서는 반드시 이 함수를 호출.
  ex) conn.commit()
- rollback(): 이전 커밋 시점으로 데이터베이스를 되돌림.
              이 함수를 호출하면, 이전 커밋 이후에 변경된 데이터는 모두 삭제됨.
  ex) conn.rollback()

"""

################################### Day21,22,23 ###################################

"""
개인 프로젝트 및 팀 편성

"""


###################################### Day24 ######################################



